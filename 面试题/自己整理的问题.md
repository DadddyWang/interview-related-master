# 自己整理的问题

## 计算机网络相关

![image-20220408114422727](https://typoracole.oss-cn-guangzhou.aliyuncs.com/img/image-20220408114422727.png)

### AB建立TCP连接，A正在B发包，然后网线断了，A会发生什么？

网线断了之后,A向B发送的数据报文不会得到任何响应，在等待一定时长后就会触发超时重传机制，重传未得到响应的数据报文。

**如果在服务端重传报文的过程中，客户端刚好把网线插回去了**

拔掉网线并不会改变客户客户端的TCP连接状态，并且仍处于ESTABLISHED状态，所以这时客户端可以正常接收服务端发来的数据报文，然后客户端会回ACK响应报文。

**一直没有把网线插回去**

服务端超时重传报文的次数到达一定阈值后，内核回判定该TCP有问题，然后通过Socket接口告诉应用程序TCP出错，随后连接断开。而等插回网线后，如果客户端向服务端发送数据，由于服务端已经没有与客户端相同四元组的TCP连接了，因此服务端内核就会回复RST报文，客户端收到后就会释放该TCP链接。此时，客户端与服务端的TCP连接都已经断开了。

**TCP的报文具体重传几次**

在 Linux 系统中，提供了一个叫 tcp_retries2 配置项，默认值是 15，如下图：

这个内核参数是控制![img](https://img-blog.csdnimg.cn/img_convert/f92c00c7e9cd01e89326e943232e5f04.png)，在 TCP 连接建立的情况下，超时重传的最大次数。

不过 tcp_retries2 设置了 15 次，并不代表 TCP 超时重传了 15 次才会通知应用程序终止该 TCP 连接，内核还会基于「最大超时时间」来判定。

每一轮的超时时间都是倍数增长的，比如第一次触发超时重传是在 2s 后，第二次则是在 4s 后，第三次则是 8s 后，以此类推。

内核会根据 tcp_retries2 设置的值，计算出一个最大超时时间。

在重传报文且一直没有收到对方响应的情况时，先达到「最大重传次数」或者「最大超时时间」这两个的其中一个条件后，就会停止重传，然后就会断开 TCP 连接。

**拔掉网线后，没有数据传输**

keepalive机制：

如果双方都没有开启 TCP keepalive 机制，那么在客户端拔掉网线后，如果客户端一直不插回网线，那么客户端和服务端的 TCP 连接状态将会一直保持存在。
如果双方都开启了 TCP keepalive 机制，那么在客户端拔掉网线后，如果客户端一直不插回网线，TCP keepalive 机制会探测到对方的 TCP 连接没有存活，于是就会断开 TCP 连接。而如果在 TCP 探测期间，客户端插回了网线，那么双方原本的 TCP 连接还是能正常存在。

### osi参考模型分为哪几层，各层的功能是什么?

**OSI参考模型包括7层，物理层、数据链路层、网络层、传输层、会话层、表示层和应用层。**

**各自的作用如下：**

1、物理层的主要功能是利用传输介质为数据链路层提供物理联接，负责数据流的物理传输工作。物理层传输的基本单位是比特流，即0和1，也就是最基本的电信号或光信号，是最基本的物理传输特征。

2、数据链路层是在通信实体间建立数据链路联接，数据链路控制子层会接受网络协议数据、分组的数据报并且添加更多的控制信息，从而把这个分组传送到它的目标设备。

3、网络层是以路由器为最高节点俯瞰网络的关键层，它负责把分组从源网络传输到目标网络的路由选择工作。互联网是由多个网络组成在一起的一个集合，正是借助了网络层的路由路径选择功能，才能使得多个网络之间的联接得以畅通，信息得以共享。

4、传输层使用网络层提供的网络联接服务，依据系统需求可以选择数据传输时使用面向联接的服务或是面向无联接的服务。

5、会话层的主要功能是通信管理。负责建立和断开通信连接（数据流动的逻辑通路）。管理传输层以下的分层。具体是何时建立连接，何时断开连接以及保持多久的连接。

6、表示层的主要功能是处理在两个通信系统中交换信息的表示方式，主要包括数据格式变化、数据加密与解密、数据压缩与解压等。这使得应用程序不必担心在各台主机中内部格式不同的问题。在网络带宽一定的前提下数据压缩的越小其传输速率就越快。表示层的数据压缩与解压被视为掌握网络传输速率的关键因素。

7、应用层采用不同的应用协议来解决不同类型的应用要求，并且保证这些不同类型的应用所采用的低层通信协议是一致的。应用层中包含了若干独立的用户通用服务协议模块，为网络用户之间的通信提供专用的程序服务。



### TCP如何进行流量控制？

接收方发送的确认报文中的窗口字段可以用来控制发送方窗口大小，从而影响发送方的发送速率。将窗口字段设置为0，则发送方不能发送数据。



### web页面请求过程大致分为哪几步？

1.DHCP配置主机信息

2.ARP解析MAC地址

3.DNS解析域名

4.HTTP请求页面



### 拥塞控制机制的四种算法

**1.慢启动：**

意思是刚刚加入网络的连接，一点一点的提速，不要一上来就把路占满。

连接建好的开始先初始化cwnd=1，表明可以传一个MSS大小的数据。

每当收过一个ACK,cwnd++；呈线性上升

每当过了一个RTT,cwnd=cwnd*2；呈指数上升

阈值ssthresh，是一个上限，当cwnd>=ssthresh时，就会进入“拥塞避免算法”。

**2.拥塞避免：**

当拥塞窗口cwnd达到一个阈值时，窗口大小不再呈指数上升，而是以线性上升，避免增长过快导致网络拥塞。

每当收到一个ACK，cwnd=cwnd+1/cwnd；

每当过了一个RTT，cwnd=cwnd+1；

**拥塞发生**：当发生丢包进行数据包重传时，表示网络已经拥塞。分两种情况处理：

等到RTO超时，重传数据包

sshthresh=cwnd/2

cwnd重置为1

**3.进入慢启动过程**

在收到三个duplicate ACK时开启重传，而不用等到RTO超时。

sshthresh=cwnd=cwnd/2

进入到快速恢复算法——Fast Recovery

**4.快速恢复**

至少收到3个Duplicated ACK，说明网络也没有非常糟糕，可以快速恢复。

cwnd=sshthresh+3*MSS （3的意思是确认有三个数据包被收到了）

如果再收到duplicate ACK 那么cwnd++；

如果再收到新的ACK 那么cwnd=sshthresh，然后就进入拥塞避免算法了。



### Map和Set的区别

map和set都是stl中的关联容器，map以键值对形式存储，key=value组成pair，是一组映射关系。set只有值，可以认为只有一个数据，并且set中元素不可以重复且自动排序，如果需要重复则使用multiset，要说区别的话，存储的东西不一样,应用场景不一样，支持的操作也不一样，很多不同。
map和set支持快速查找和删除，一般使用RB树来实现，当然后面还有用hashtable实现的，使用rb树作为底层结构增删数据都很快，不存在内存移动也就不容易出现迭代器失效的问题，这也就是区别于vector的原因-内存移动
Map中的每一个元素包含一个键对象和值对象，它们成对出现。键对象不能重复，值对象可以重复。
Set中的对象不按特定方式排序，并且没有重复对象。但它的有些实现类能对集合中的对象按特定方式排序，例如TreeSet类，它可以按照默认排序，也可以通过实现java.util.Comparator接口来自定义排序方式。

总结如下：

set是一种关联式容器，其特性如下：

set以RBTree作为底层容器
所得元素的只有key没有value，value就是key
不允许出现键值重复
所有的元素都会被自动排序
不能通过迭代器来改变set的值，因为set的值就是键
map和set一样是关联式容器，它们的底层容器都是红黑树，区别就在于map的值不作为键，键和值是分开的。它的特性如下：

map以RBTree作为底层容器
所有元素都是键+值存在
不允许键重复
所有元素是通过键进行自动排序的
map的键是不能修改的，但是其键对应的值是可以修改的

## C++语法 #

### C++11 引入的新特性

**auto关键字**

在C++14中 auto可以作为函数的返回值，不过auto作为函数返回值时，只能用于定义函数，不能用于声明函数。

**nullptr和NULL的区别**

NULL在C++中表示的是字面值常量的0 ,它只是一个宏定义, 而nullptr则是一个C++的关键字, 它表示为"声明一个空指针" 它可以转换成任何指针类型和bool类型，但是不能被转换为整数。

**lambda匿名函数**

为什么C++11要弄出来这个匿名函数机制？（有一些函数只是临时用一下，业务逻辑比较简单，没有必要给它定义成一个正常函数。使用临时的匿名函数，可以减轻函数的数量，让代码变的清晰易读。

**STL容器**

std::array

相对于普通数组增加了，迭代器等函数

std::forward_list

新增的线性表，与list区别在于它是单向链表。链表在对于数据插入和删除是比顺序存储的线性表有优势，因此在插入和删除操作频繁的应用场景中，使用list和forward_list比使用array、vector和deque效率要高很多。

std::unordered_map

std::unordered_map与std::map用法基本差不多，但STL在内部实现上有很大不同，std::map使用的数据结构为二叉树，而std::unordered_map内部是哈希表的实现方式，哈希map理论上查找效率为O(1)。但在存储效率上，哈希map需要增加哈希表的内存开销。

std::unordered_set

std::unordered_set的数据存储结构也是哈希表的方式结构，除此之外，std::unordered_set在插入时不会自动排序，这都是std::set表现不同的地方。

**多线程**

std::thread

std::thread为C++11的线程类，使用方法和boost接口一样，非常方便，同时，C++11的std::thread解决了boost::thread中构成参数限制的问题，我想着都是得益于C++11的可变参数的设计风格。

std::atomic

是C++11封装的原子数据类型

什么是原子数据类型？

从功能上看，简单地说，原子数据类型不会发生数据竞争，能直接用在多线程中而不必我们用户对其进行添加互斥资源锁的类型。从实现上，大家可以理解为这些原子类型内部自己加了锁。

std::condition_variable

C++11中的std::condition_variable就像Linux下使用pthread_cond_wait和pthread_cond_signal一样，可以让线程休眠，直到被唤醒，再重新执行。线程等待在多线程编程中使用非常频繁，经常需要等待一些异步执行的条件的返回结果。

**智能指针内存管理**

*std::shared_ptr*

包装了new操作符动态分别的内存，可以自由拷贝复制，是使用最多的一个智能指针类型。

std::make_shared封装了new方法，boost::make_shared之前的原则是既然释放资源delete由智能指针负责，那么应该把new封装起来，否则会让人觉得自己调用了new，但没有调用delete，似乎与谁申请，谁释放的原则不符。C++也沿用了这一做法。

注意：相互引用引起释放条件的冲突最后会导致内存泄漏问题

*std::weak_ptr*

std::weak_ptr网上很多人说其实是为了解决std::shared_ptr在相互引用的情况下出现的问题而存在的，C++官网对这个只能指针的解释也不多，那就先甭管那么多了，让我们暂时完全接受这个观点。

**其他**

std:function、std::bind封装可执行对象

lambda表达式

### 说说new和malloc的区别，各自底层实现原理

**参考回答**

1. new是操作符，而malloc是函数。
2. new在调用的时候先分配内存，在调用构造函数，释放的时候调用析构函数；而malloc没有构造函数和析构函数。
3. malloc需要给定申请内存的大小，返回的指针需要强转；new会调用构造函数，不用指定内存的大小，返回指针不用强转。
4. new可以被重载；malloc不行
5. new分配内存更直接和安全。
6. new发生错误抛出异常，malloc返回null

**malloc底层实现：**当开辟的空间小于 128K 时，调用 brk（）函数；当开辟的空间大于 128K 时，调用mmap（）。malloc采用的是内存池的管理方式，以减少内存碎片。先申请大块内存作为堆区，然后将堆区分为多个内存块。当用户申请内存时，直接从堆区分配一块合适的空闲快。采用隐式链表将所有空闲块，每一个空闲块记录了一个未分配的、连续的内存地址。

**new底层实现：**关键字new在调用构造函数的时候实际上进行了如下的几个步骤：

1. 创建一个新的对象
2. 将构造函数的作用域赋值给这个新的对象（因此this指向了这个新的对象）
3. 执行构造函数中的代码（为这个新对象添加属性）
4. 返回新对象

###　C++程序到可执行文件的过程

对于C++源文件，从文本到可执行文件一般需要四个过程：

１．预处理阶段：对源代码文件中文件包含关系（头文件）、预编译语句（宏定义）进行分析和替换，生成预编译文件。
２．编译阶段：将经过预处理后的预编译文件转换成特定汇编代码，生成汇编文件。根据当前源代码编译成二进制目标文件（即.obj文件）
３．汇编阶段：将编译阶段生成的汇编文件转化成机器码，生成可重定位目标文件。
４．链接阶段：将多个目标文件及所需要的库连接成最终的可执行目标文件。将生成的.obj文件与库文件.lib等文件链接，生成可执行文件（.exe文件）。

### vector 尾部添加元素，需要扩容连续的内存空间吗？

在vector类中作用为在vector尾部加入一个数据；即vector的size属性加1，但此时还要判断 (size+1)与capacity的关系，如果(size+1)>capacity，则说明集合已经满了，在新增数据的时候，就要分配一块更大的内存，将原来的数据复制过来，释放之前的内存，再插入新增的元素；

**问题**：**为什么要成倍的扩容而不是一次增加一个固定大小的容量呢？为什么是以两倍的方式扩容呢？？**

**答：成倍扩展是为了保证常数时间的复杂度，以2倍方式扩容是为了防止内存的浪费，更好的实现对内存的利用。**

###　智能指针

一. 智能指针的基本概念
1. RAII（Resource Acquisition Is Initialization）是一种利用对象生命周期来控制程序资源（如内存、文件句柄、网络连接、互斥量等等）的简单技术。
在对象构造时获取资源，接着控制对资源的访问使之在对象的生命周期内始终保持有效，最后在对象析构的时候释放资源。借此，我们实际上把管理一份资源的责任托管给了一个对象。这种做法有两大好处：

　　不需要显式地释放资源。 
　　采用这种方式，对象所需的资源在其生命期内始终保持有效。
2.智能指针概念
    在c++中，动态内存的管理式通过一对运算符来完成的：new,在动态内存中为对象分配空间并返回一个指向该对象的指针，我们可以选择对对象进行初始化；delete，接受一个动态对象的指针，销毁该对象，并释放与之关联的内存。动态内存的使用很容易出现问题，因为确保在正确的时间释放内存是极其困难的。有时使用完对象后，忘记释放内存，造成内存泄漏的问题。

  所谓的智能指针本质就是一个类模板，它可以创建任意的类型的指针对象，当智能指针对象使用完后，对象就会自动调用析构函数去释放该指针所指向的空间。
下面是智能指针的基本框架，所有的智能指针类模板中都需要包含一个指针对象，构造函数和析构函数。

二、C＋＋库中的智能指针

auto_ptr是C++98版本库中提供的智能指针，解决上诉问题采取的措施是管理权转移思想，即 **原对象拷贝给新对象的时候，原对象就会被设置为nullptr**,此时就只有新对象指向一块资源空间。**如果auto_ptr调用拷贝构造函数或者赋值重载函数后，如果再去使用原来的对象的话，整个程序都会崩溃(因为原对象被设置为nullptr)**,这对程序有很大伤害，所以很多公司会禁用该智能指针。



unique_ptr是C++11版本库中提供的智能指针，它禁用了拷贝构造函数和赋值重载函数，因此不让其进行拷贝和赋值。



**share_ptr**是C++11版本库中的智能指针，shared_ptr允许多个智能指针可以指向同一块资源，并且能够保证共享的资源只会被释放一次，并且程序不会崩溃。

采用的是**引用计数原理**来实现多个shared_ptr对象之间共享资源：

​    shared_ptr在内部会**维护一份引用计数**，用来记录该对象被几个对象共享。

​    当一个**shared_ptr对象被销毁时**(调用析构函数),**析构函数内就会将该计数减一。**

​    如果引用计数减为零后，表示自己是最后一个使用该资源的shared_ptr对象，必须释放资源。

​    如果引用计数不是0，就说明自己还有其他对象在使用，**则不能释放资源**，否则其他对象就成为野指针。

引用计数是用来记录资源对象中有多少个指针指向该对象资源

**shared_ptr的问题**

**循环引用**问题

当创建出node1，node2智能指针对象时，引用计数都是1。当node1的next指向node2所指资源时node2计数+1变成2，node2的pre指向node1所指向资源，node1引用计数+1变成2。但当这两个智能指针使用完后调用析构函数-1都变成1，但计数不为0，所以两者指向的对象都不会被释放。

**如何解决**

C++库中存在weak_ptr类型的智能指针。**weak_ptr类的对象可以指向shared_ptr，并且不会改变shared_ptr的计数**。最后一个shared_ptr被销毁时，对象就会得到释放。

**定制删除器**

当我们释放一个指向数组的指针时，delete[]后面的空方括号是必须存在的。

因此,shared_ptr类中提供了一个构造函数可以自定义一个删除器去指定析构函数的删除方式。这个自定义删除器可以是**函数指针，仿函数，lamber，包装器**。



### 检查内存泄漏的方法

1、在Linux平台上 有valgrind可以非常方便的帮助我们定位内存泄漏，因为Linux在开发领域的使用场景大多是跑服务器，再加上它的开源属性，相对而言处理问题容易形成“统一”的标准。

2、对象计数

而在Windows平台，服务器和客户端开发人员惯用的调试方式有很大不同。

在对象构造时计数++，析构时--，每隔一段时间打印对象的数量

优点：没有性能开销，几乎不占用额外内存。定位结果精确。

缺点：侵入式方法，需要修改现有的代码，而对于第三方库、STL容器、脚本泄露等因无法修改代码而无法定位。

### const与#define相比好在哪

1.能够明确指定类型。

2.可以使用C++的作用域规则将定义限制在特定的函数或文件中（作用域规则描述了名称在各种模块中的可知程度）。

3.可以将const用于更复杂的类型。



### 共用体

**一时间只能输出一种类型的数据。**共用体的一种用途是，当数据项使用两种或更多种格式**（但不会同时使用）**时，可节省空间。共用体常用于节省内存，尤其是嵌入式系统编程，如控制烤箱，MP3。对这些应用程序来说，内存可能非常宝贵。另外，共用体常用于操作系统数据结构或硬件数据结构。



### 指针的危险

1.指针还没有指向就直接对其进行赋值操作。

2.第二种错误主要是指针没有赋值为NULL就释放了内存，这样指针就变成了野指针。只要后面程序对其赋值就会有导致系统崩溃的可能。正确的做法就是用完释放的指针最好都要指向NULL，只要是指向NULL那么后期对其赋值也没事，对一个空指针赋值是安全的。因此，一开始声明指针的时候最好要置NULL初始操作，指针释放之后也要置NULL。**可以保证系统安全**



###　构造函数和析构函数能否是虚函数

构造函数不能是虚函数，因为虚函数是基于对象的，构造函数是用来产生对象的，如果构造函数是虚函数，则需要对象来调用，但是构造函数没有执行就没有对象存在，产生矛盾，所以构造函数不能是虚函数。

析构函数可以是虚函数，因为如果有父类指针指向子类对象的情况存在，需要析构的是子类对象，但是父类析构函数不是虚函数，如果只析构父类，造成子类对象没有及时释放会引起内存泄漏



# 操作系统相关

 ## 一句话概括系统调用

**系统调用可被看成是一个内核与用户空间程序交互的接口——它好比一个信使，把用户进程的请求传达给内核，待内核把请求处理完毕后再将处理结果送回给用户空间。**



## 进程与线程

在一个程序里的一个执行路线就叫做线程（thread）,更准确的定义是：线程是“一个进程内部的控制序列”。所有进程都至少有一个执行线程，也就是主线程，进程由一个或者多个线程组成，即进程中可以有多个执行流。线程是进程的一个执行分支，是在进程内部运行的一个执行流，本质是在进程地址空间内运行，共享进程的进程地址空间，执行进程的一部分代码。

- 注意：

> 1. 在Linux中，CPU只关心一个一个的独立执行流，无论进程内部只有一个执行流还是有多个执行流，CPU都是以task_struct为单位进行调度的
> 2. Linux下并不存在真正的多线程，而是用进程模拟的。如果要支持真的线程(TCB)会提高操作系统的复杂程度。而线程的和进程的控制块基本是类似实现的，因此Linux直接复用了进程控制块，所以Linux中的所有执行流都叫做轻量级进程
> 3. 在Linux中都没有真正意义的线程，所以也就没有真正意义上的线程相关的系统调用，但是Linux提供了轻量级进程相关的库和接口，例如vfork函数和原生线程库pthread

**线程的优点：**

1.创建一个新线程的代价要比创建一个新进程小得多

2.与进程之间的切换相比，线程之间的切换需要操作系统做的工作要少很多线程占用的资源要比进程少很多。

3.能充分利用多处理器的可并行数量。

4.在等待慢速I/O操作结束得同时，程序可执行其他的计算任务。

5.计算密集型应用，为了能在多处理器系统上运行，将计算分解到多个线程中实现。

6.I/O密集型应用，为了提高性能，能将I/O操作重叠。线程可以同时等待不同的I/O操作（如 边下视频边看视频）。

**线程的缺点：**

1.性能损失：一个很少被外部事件阻塞的计算密集型线程往往无法与其他线程共享同一个处理器。如果计算密集型线程的数量比可用的处理器多，那么可能会有较大的性能损失，这里的性能损失指的是增加了额外的同步和调度开销，而可用的资源不变。

2.健壮性降低：编写多线程需要更全面更深入的考虑，在一个多线程程序里，因时间分配上的细微偏差或者因为共享了不该共享的变量而造成的不良影响的可能性是很大的，换句话说线程之间是缺保护的。

3.缺乏访问控制：进程是访问控制的基本粒度，在一个线程中调用某些OS函数会对整个进程造成影响。

4.编程难度提高：编写与调试一个多线程程序比单线程程序难得多。

## 其他常见的各种锁

1、悲观锁：在每次取数据时，总是担心数据会被其他线程修改，所以会在取数据前先加锁（读锁，写锁，行锁等），当其他线程想要访问数据时，被阻塞挂起

2、乐观锁：每次取数据时候，总是乐观的认为数据不会被其他线程修改，因此不上锁。但是在更新数据前，会判断其他数据在更新前有没有对数据进行修改。主要采用两种方式：版本号机制和CAS操作

3、CAS操作：当需要更新数据时，判断当前内存值和之前取得的值是否相等。如果相等则用新值更新。若不等则失败，失败则重试，一般是一个自旋的过程，即不断重试

4、自旋锁：对于占用互斥锁的时间长短来决定是否选择使用自旋锁，如果占用锁时间长那么不用自旋锁，让线程进行挂起等待就好；如果占用时间短，使用自旋锁进行间断性获取锁申请，也就是自旋
